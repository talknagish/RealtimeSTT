<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browser STT Client</title>
  <style>
    body {
      background-color: #f4f4f9;
      color: #333;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 700px;
      padding: 20px;
      box-sizing: border-box;
      gap: 20px; /* Add more vertical space between items */
      height: 90%; /* Fixed height to prevent layout shift */
    }
    #status {
      color: #0056b3;
      font-size: 20px;
      text-align: center;
    }
    #transcriptionContainer {
      height: 90px; /* Fixed height for approximately 3 lines of text */
      overflow-y: auto;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    #transcription {
      font-size: 18px;
      line-height: 1.6;
      color: #333;
      word-wrap: break-word;
    }
    #fullTextContainer {
      height: 150px; /* Fixed height to prevent layout shift */
      overflow-y: auto;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    #fullText {
      color: #4CAF50;
      font-size: 18px;
      font-weight: 600;
      word-wrap: break-word;
    }
    .last-word {
      color: #007bff;
      font-weight: 600;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      margin: 5px;
      transition: background-color 0.3s ease;
      color: #fff;
      background-color: #0056b3;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      background-color: #007bff;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="status">Press "Start Recording"...</div>
    <button id="startButton" onclick="startRecording()">Start Recording</button>
    <button id="stopButton" onclick="stopRecording()" disabled>Stop Recording</button>
    <div id="transcriptionContainer">
      <div id="transcription" class="realtime"></div>
    </div>
    <div id="fullTextContainer">
      <div id="fullText"></div>
    </div>
  </div>

  <script>
    const statusDiv = document.getElementById("status");
    const transcriptionDiv = document.getElementById("transcription");
    const fullTextDiv = document.getElementById("fullText");
    const startButton = document.getElementById("startButton");
    const stopButton = document.getElementById("stopButton");

    const controlURL = "wss://stt.talknagish.com/control";
    const dataURL = "wss://stt.talknagish.com/data";
    let dataSocket;
    let audioContext;
    let mediaStream;
    let mediaProcessor;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 5;
    let reconnectDelay = 1000; // 1 second
    let isRecording = false;

    let isReconnecting = false;
    let reconnectTimeout = null;

    // Connect to the data WebSocket
    async function connectToDataSocket() {
      if (isReconnecting) {
        console.log("Already attempting to reconnect, skipping...");
        return;
      }

      isReconnecting = true;
      
      // Clear any existing reconnect timeout
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }

      // Close existing socket if it exists
      if (dataSocket) {
        try {
          dataSocket.close(1000, "Intentional disconnect");
          // Wait for socket to close
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (e) {
          console.warn("Error closing existing socket:", e);
        }
        dataSocket = null;
      }

      // Clear transcription displays before reconnecting
      transcriptionDiv.textContent = "";
      fullTextDiv.textContent = "";

      try {
        dataSocket = new WebSocket(dataURL);
        
        // Set a connection timeout
        const connectionTimeout = setTimeout(() => {
          if (dataSocket && dataSocket.readyState === WebSocket.CONNECTING) {
            console.warn("Connection timeout, closing socket");
            dataSocket.close();
          }
        }, 5000);

        dataSocket.onopen = () => {
          clearTimeout(connectionTimeout);
          statusDiv.textContent = "Connected to STT server.";
          console.log("Connected to data WebSocket.");
          reconnectAttempts = 0;
          isReconnecting = false;
          
          // Wait for server ready status
          let readyTimeout = setTimeout(() => {
            if (isRecording) {
              statusDiv.textContent = "Resuming transcription...";
            }
          }, 1000);

          // Clear timeout if we get a ready status message
          const originalOnMessage = dataSocket.onmessage;
          const tempHandler = (event) => {
            try {
              const message = JSON.parse(event.data);
              if (message.type === "status" && message.status === "ready") {
                clearTimeout(readyTimeout);
                if (isRecording) {
                  statusDiv.textContent = "Resuming transcription...";
                }
                // Restore original message handler
                dataSocket.onmessage = originalOnMessage;
              }
            } catch (e) {
              console.warn("Error parsing message in temp handler:", e);
            }
          };
          dataSocket.onmessage = tempHandler;
        };

      dataSocket.onmessage = (event) => {
        console.log("Received message:", event.data);
        try {
          const message = JSON.parse(event.data);
          console.log("Parsed message:", message);

          if (message.type === "realtime") {
            console.log("Processing realtime message:", message.text);
            // Show real-time transcription with the last word in bold, orange
            let words = message.text.split(" ");
            let lastWord = words.pop();
            transcriptionDiv.innerHTML = `${words.join(" ")} <span class="last-word">${lastWord}</span>`;

            // Auto-scroll to the bottom of the transcription container
            const transcriptionContainer = document.getElementById("transcriptionContainer");
            transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;
          } else if (message.type === "fullSentence") {
            console.log("Processing fullSentence message:", message.text);
            // Accumulate the final transcription in green
            fullTextDiv.innerHTML += message.text + " ";
            transcriptionDiv.innerHTML = message.text;

            // Scroll to the bottom of fullTextContainer when new text is added
            const fullTextContainer = document.getElementById("fullTextContainer");
            fullTextContainer.scrollTop = fullTextContainer.scrollHeight;
          } else {
            console.log("Ignoring message type:", message.type);
          }
        } catch (e) {
          console.error("Error parsing message:", e);
        }
      };

      dataSocket.onclose = async (event) => {
        console.log("WebSocket closed:", event.code, event.reason);
        
        // Don't attempt reconnect if we're intentionally closing
        if (event.code === 1000 && event.reason === "Intentional disconnect") {
          console.log("Intentional disconnect, not attempting reconnect");
          statusDiv.textContent = "Disconnected from STT server.";
          isReconnecting = false;
          return;
        }
        
        // Handle 1005 errors specifically
        if (event.code === 1005) {
          console.log("Received 1005 error, performing full reset before reconnect");
          // Wait a bit longer before reconnecting on 1005 errors
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Reset all audio processing
          if (mediaProcessor && audioContext) {
            try {
              mediaProcessor.disconnect();
              await audioContext.close();
              mediaProcessor = null;
              audioContext = null;
            } catch (e) {
              console.warn("Error resetting audio processing:", e);
            }
          }
        }
        
        statusDiv.textContent = "Connection lost. Attempting to reconnect...";
        
        // Attempt to reconnect if we're still recording
        if (isRecording && reconnectAttempts < maxReconnectAttempts) {
          console.log(`Attempting to reconnect... (${reconnectAttempts + 1}/${maxReconnectAttempts})`);
          statusDiv.textContent = `Reconnecting... (${reconnectAttempts + 1}/${maxReconnectAttempts})`;
          
          // Exponential backoff for reconnect delay
          const currentDelay = reconnectDelay * Math.pow(1.5, reconnectAttempts);
          
          reconnectTimeout = setTimeout(async () => {
            reconnectAttempts++;
            try {
              // Reinitialize audio context if needed
              if (!audioContext || audioContext.state === 'closed') {
                audioContext = new AudioContext();
                await setupAudioProcessing();
              }
              await connectToDataSocket();
            } catch (e) {
              console.error("Error during reconnect:", e);
              statusDiv.textContent = "Error reconnecting. Please try again.";
            }
          }, currentDelay);
        } else if (reconnectAttempts >= maxReconnectAttempts) {
          statusDiv.textContent = "Failed to reconnect. Please stop and restart recording.";
          console.log("Max reconnection attempts reached");
          isRecording = false;
          startButton.disabled = false;
          stopButton.disabled = true;
        }
      };

      dataSocket.onerror = (error) => {
        console.error("WebSocket error:", error);
        statusDiv.textContent = "Error connecting to the STT server.";
      };
    }

    // Set up audio processing
    async function setupAudioProcessing() {
      if (!audioContext) {
        audioContext = new AudioContext();
      }
      
      if (!mediaStream) {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      }
      
      const input = audioContext.createMediaStreamSource(mediaStream);
      
      // Set up processor for audio chunks
      mediaProcessor = audioContext.createScriptProcessor(1024, 1, 1);
      mediaProcessor.onaudioprocess = (event) => {
        if (isRecording && dataSocket && dataSocket.readyState === WebSocket.OPEN) {
          const audioData = event.inputBuffer.getChannelData(0);
          sendAudioChunk(audioData, audioContext.sampleRate);
        }
      };
      
      input.connect(mediaProcessor);
      mediaProcessor.connect(audioContext.destination);
      
      return true;
    }

    // Start recording audio from the microphone
    async function startRecording() {
      try {
        startButton.disabled = true;
        stopButton.disabled = false;
        statusDiv.textContent = "Initializing...";
        transcriptionDiv.textContent = "";
        fullTextDiv.textContent = "";
        isRecording = true;
        reconnectAttempts = 0;
        
        // Initialize audio processing
        await setupAudioProcessing();
        
        // Connect to WebSocket only after audio is set up
        statusDiv.textContent = "Connecting to server...";
        await connectToDataSocket();
      } catch (error) {
        console.error("Error accessing microphone:", error);
        statusDiv.textContent = "Error accessing microphone.";
        stopRecording();
      }
    }

    // Stop recording audio and close resources
    async function stopRecording() {
      isRecording = false;
      
      // Stop audio processing first
      if (mediaProcessor && audioContext) {
        try {
          mediaProcessor.disconnect();
          await audioContext.close();
        } catch (e) {
          console.warn("Error closing audio context:", e);
        }
      }

      // Stop media stream
      if (mediaStream) {
        try {
          mediaStream.getTracks().forEach(track => track.stop());
        } catch (e) {
          console.warn("Error stopping media stream:", e);
        }
      }

      // Close WebSocket connection with a small delay to allow final messages
      if (dataSocket) {
        try {
          // Small delay to allow any final messages to be sent
          await new Promise(resolve => setTimeout(resolve, 100));
          dataSocket.close();
        } catch (e) {
          console.warn("Error closing WebSocket:", e);
        }
      }

      // Reset UI state
      startButton.disabled = false;
      stopButton.disabled = true;
      statusDiv.textContent = "Stopped recording.";
      
      // Clear audio processing resources
      mediaProcessor = null;
      audioContext = null;
      mediaStream = null;
      dataSocket = null;
    }

    // Send an audio chunk to the server
    function sendAudioChunk(audioData, sampleRate) {
      if (dataSocket && dataSocket.readyState === WebSocket.OPEN) {
        const float32Array = new Float32Array(audioData);
        const pcm16Data = new Int16Array(float32Array.length);

        for (let i = 0; i < float32Array.length; i++) {
          pcm16Data[i] = Math.max(-1, Math.min(1, float32Array[i])) * 0x7FFF;
        }

        const metadata = JSON.stringify({ sampleRate });
        const metadataLength = new Uint32Array([metadata.length]);
        const metadataBuffer = new TextEncoder().encode(metadata);

        const message = new Uint8Array(
          metadataLength.byteLength + metadataBuffer.byteLength + pcm16Data.byteLength
        );
        
        message.set(new Uint8Array(metadataLength.buffer), 0);
        message.set(metadataBuffer, metadataLength.byteLength);
        message.set(new Uint8Array(pcm16Data.buffer), metadataLength.byteLength + metadataBuffer.byteLength);

        dataSocket.send(message);
      }
    }
  </script>
</body>
</html>
